#!/bin/bash

# Set the base directory and important paths
BASE_DIR="/srv/scratch/z3546698/true/pod5/"
REFERENCE="/srv/scratch/z3546698/true/reference/hg38.fa"
ANNOTATION="/srv/scratch/z3546698/true/reference/Homo_sapiens.GRCh38.110.gtf"
OUTPUT_DIR="$BASE_DIR/output"
MODEL_DIR="/path/to/dorado/models"  # Set the correct path to Dorado models

# Create necessary directories
mkdir -p "$OUTPUT_DIR/fastq_pass"
mkdir -p "$OUTPUT_DIR/fastq_fail"
mkdir -p "$OUTPUT_DIR/step1"
mkdir -p "$OUTPUT_DIR/quality_control"
mkdir -p "$OUTPUT_DIR/step2"
mkdir -p "$OUTPUT_DIR/step3"
mkdir -p "$OUTPUT_DIR/step4"

# Step 1: Merge .pod5 files and convert them to .fastq using Dorado
# This step involves merging all .pod5 files from each barcode directory and then converting these merged files into .fastq format using the Dorado basecaller. This prepares raw sequencing data for subsequent trimming and analysis.

echo "Merging .pod5 files and converting them to .fastq..."
for STATE in pod5_pass pod5_fail; do

    # Directory to store the merged .pod5 files
    merged_pod5_dir="$OUTPUT_DIR/merged_$STATE"
    mkdir -p "$merged_pod5_dir"

    # Merge .pod5 files per directory and keep track
    find "$BASE_DIR/$STATE" -type d -mindepth 1 -maxdepth 1 | while read -r barcode_dir; do
        merged_pod5_file="$merged_pod5_dir/$(basename "$barcode_dir").pod5"
        
        # Use npmerge or cat if applicable to merge .pod5 formats
        echo "Merging pod5 files in $barcode_dir..."
        # Here, you might need to adjust to a valid .pod5 merging command
        # For illustration, assuming `npmerge` is a command to merge .pod5 files:
        npmerge "$barcode_dir"/*.pod5 -o "$merged_pod5_file"
        
        dorado_out="$OUTPUT_DIR/fastq_${STATE#pod5_}/$(basename "$barcode_dir")"
        mkdir -p "$dorado_out"
        
        # Basecalling with Dorado
        dorado basecaller --model "$MODEL_DIR/model_name.dor" --device "cuda" "$merged_pod5_file" "$dorado_out"

        echo "Converted: $merged_pod5_file -> $dorado_out"
        
        # Optionally remove merged .pod5 files after conversion
        rm "$merged_pod5_file"
    done
done

# Step 2: Trimming fastq files using Porechop from fastq_pass directory
# The aim of this step is to trim adapter sequences and other unwanted elements from the fastq files that were generated from the pod5 conversion. Porechop is used for this task to ensure clean and high-quality data is available for quality control.

echo "Trimming fastq files using Porechop..."
for STATE in fastq_pass fastq_fail; do
    find "$OUTPUT_DIR/$STATE" -type f -name "*.fastq.gz" | while read -r fastq_file; do
        step1_dir="$OUTPUT_DIR/step1/$(basename "$(dirname "$fastq_file")")"
        mkdir -p "$step1_dir"
        output_file="$step1_dir/$(basename "${fastq_file%.fastq*}_trimmed.fastq.gz")"
        porechop -i "$fastq_file" -o "$output_file"
        echo "Trimmed: $fastq_file -> $output_file"
    done
done

# Step 3: Quality Control via NanoPlot
# This stage ensures that the trimmed fastq files meet the required quality standards. NanoPlot provides a graphical and statistical summary of the read quality, guiding decisions for any further data filtering required.

echo "Quality Control in progress..."
find "$OUTPUT_DIR/step1" -type f -name "*_trimmed.fastq.gz" | while read -r trimmed_file; do
    quality_control_dir="$OUTPUT_DIR/quality_control/$(basename "$(dirname "$trimmed_file")")"
    mkdir -p "$quality_control_dir"
    NanoPlot --fastq "$trimmed_file" --outdir "$quality_control_dir"
done

echo "Quality Control finished..."

# Step 4: Alignment and BAM file generation
# After quality control, the trimmed sequences are aligned to the reference genome using BWA. This alignment is crucial for positioning reads in the genome, thereby facilitating subsequent analyses like variant calling or expression analysis.

echo "Alignment and BAM file generation in progress..."
find "$OUTPUT_DIR/step1" -type f -name "*_trimmed.fastq.gz" | while read -r trimmed_file; do
    dir="$OUTPUT_DIR/step2/$(basename "$(dirname "$trimmed_file")")"
    mkdir -p "$dir"
    basename=$(basename "$trimmed_file" .fastq.gz)
    output_bam="$dir/${basename}.bam"
    bwa mem "$REFERENCE" "$trimmed_file" | samtools view -Sb - > "$output_bam"
    echo "BAM file generated: $output_bam"
done

# Step 5: Sort and mark duplicates in BAM files
# This step involves sorting the BAM files and marking duplicate reads to eliminate bias in downstream analyses. Sorted BAM files allow for efficient data indexing and retrieval, while marking duplicates improves the accuracy of variant calling.
echo "Sorting and marking duplicates in BAM files..."
find "$OUTPUT_DIR/step2" -type f -name "*.bam" | while read -r bam_file; do
    dir="$OUTPUT_DIR/step3/$(basename "$(dirname "$bam_file")")"
    mkdir -p "$dir"
    sorted_bam="$dir/$(basename "${bam_file%.bam}_sorted.bam")"
    marked_bam="$dir/$(basename "${bam_file%.bam}_marked.bam")"

    # Sort BAM files
    samtools sort -o "$sorted_bam" "$bam_file"
    echo "Sorted BAM file: $sorted_bam"

    # Mark duplicates
    samtools markdup "$sorted_bam" "$marked_bam"
    echo "Marked duplicates in BAM file: $marked_bam"

    # Clean up intermediate files if needed
    rm "$sorted_bam"
done

# Step 6: Generate alignment statistics and reports
# This stage generates comprehensive reports on the mapping quality and efficiency by examining the BAM files with marked duplicates. These statistics are essential for verifying the success and accuracy of the sequencing and alignment processes.
echo "Generating alignment statistics and reports..."
find "$OUTPUT_DIR/step3" -type f -name "*_marked.bam" | while read -r marked_bam; do
    dir="$OUTPUT_DIR/reports/$(basename "$(dirname "$marked_bam")")"
    mkdir -p "$dir"

    # Produce alignment statistics using samtools
    samtools flagstat "$marked_bam" > "$dir/$(basename "${marked_bam%.bam}_flagstat.txt")"
    echo "Alignment statistics report generated for: $marked_bam"

    # Optionally, generate additional QC metrics
    # qualimap bamqc -bam "$marked_bam" -outdir "$dir/qualimap_report"
done

# Step 7: Feature counting with featureCounts
# In the final processing step, featureCounts quantifies gene expression levels by counting mapped reads at annotated genomic features. This quantification is crucial for differential expression analysis or other transcriptomic studies.
echo "Feature counting with featureCounts..."
find "$OUTPUT_DIR/step3" -type f -name "*_marked.bam" | while read -r marked_bam; do
    dir="$OUTPUT_DIR/step4/$(basename "$(dirname "$marked_bam")")"
    mkdir -p "$dir"
    
    output_counts="${dir}/$(basename "${marked_bam%.bam}_counts.txt")"
    featureCounts -a "$ANNOTATION" -o "$output_counts" -T 4 "$marked_bam"
    
    echo "Feature counts generated in: $output_counts"
done

echo "Pipeline completed. Please check the output directories for results and reports!"
