#!/bin/bash

# Function to display a spinning progress indicator
spinner() {
    local pid=$!
    local delay=0.1
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep "$pid")" ]; do
        local temp=${spinstr#?}
        printf " [%c]  \b\b\b\b\b" "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
    done
    printf "    \b\b\b\b"
}

#Load the module available on Katana

module load dorado/0.7.3


# Display the logo from logo.sh
source ./logo.sh

# Suppress function output using redirection
run_command() {
    ("$@") >/dev/null 2>&1 &
    spinner
}

# This script walks through the bioinformatics pipeline, starting from basecalling with Dorado, conducting quality control with NanoPlot,
# performing alignment, sorting, marking duplicates, and finally generating gene counts with featureCounts. Each step is crucial for
# ensuring high-quality, analyzable data from raw experimental results.






# Step 1: Basecalling using Dorado and Quality Control using NanoPlot
# The first step in the pipeline focuses on converting raw nanopore sequencing data (.fast5 files) into basecalled sequences (in .fastq format).
# We employ the Dorado tool for basecalling, followed by quality control analysis using NanoPlot, which provides comprehensive data visualization
# on the quality of the sequencing run.

# Step 1: Basecalling using Dorado and Quality Control using NanoPlot
echo "Starting Step 1: Basecalling and Quality Control..."
FOLDER="/mnt/d/Small_Molecule/Biotin/T7MB-2/240421"  # Path to input experiments folders
MODEL="/path/to/dorado/model"  # Specify the Dorado model path

# Go to the working folder or print an error
cd "$FOLDER" || { echo "Folder not found"; exit 1; }

# Basecalling using Dorado
echo "Basecalling starts using Dorado......"

# Use find to locate all .fast5 files in the directory and subdirectories
find . -type f -name "*.fast5" | while read -r file; do
    if [ -f "$file" ]; then
        # Define output file name. Adjust as needed to fit Dorado's requirements.
        output_file="${file%.fast5*}_basecalled.fastq"
        # Run Dorado basecalling command
        run_command dorado basecaller "$MODEL" "$file" --output "$output_file"
        echo "Basecalled: $file -> $output_file"
    fi
done

# Conducting Quality Control via NanoPlot on basecalled fastq
echo "Basecalling finished......."
echo "Quality Control in progress......."

# Find and run NanoPlot on all basecalled files
find . -type f -name "*_basecalled.fastq" | while read -r basecalled_file; do
    run_command NanoPlot --fastq "$basecalled_file" --outdir "${basecalled_file%.fastq}_nanoplot"
done

echo "Step1 completed. Please check the sequencing quality report!"

# Step 2: Converting and Alignment
# In the second step, the focus is on aligning the sequence reads to a reference genome. This step includes
# the conversion of the raw FASTQ data into BAM format using the bwa mem for alignment, followed by samtools
# for reading conversion. Aligning reads to a reference helps in identifying the positions of genetic sequences
# in relation to the reference genome.

# Step 2: Converting and Alignment
echo "Starting Step 2: Converting and Alignment..."
#!/bin/bash

# Identify folder path and reference path
REFERENCE="/mnt/d/hg38/hg38.fa"

# Walk through each relevant FASTQ file for comparison and generate the BAM file
find "$FOLDER" -type f -name "*_trimmed.fastq.gz" | while read -r trimmed_file; do
    # trimmed file path
    dir=$(dirname "$trimmed_file")
    
    # acquiring filenames prefix
    basename=$(basename "$trimmed_file" .fastq.gz)

    # output bam files path
    output_bam="$dir/${basename}.bam"

    # conduct alignment and generate
    bwa mem "$REFERENCE" "$trimmed_file" | samtools view -Sb - > "$output_bam"

    echo "BAM file generated: $output_bam"
done


echo "Step 2 completed."

# Step 3: Sorting and Marking Duplicates
# This step takes the aligned data in BAM format and sorts them before marking duplicate entries. Sorting facilitates
# efficient data processing and analysis, while marking duplicates ensures that downstream analysis like variant calling
# considers unique sequences, improving the quality of results.


# Step 3: Sorting and Marking Duplicates
echo "Starting Step 3: Sorting and Marking Duplicates..."
find "$FOLDER" -type f -name "*.bam" | while read -r bam_file; do
    dir=$(dirname "$bam_file")
    basename=$(basename "$bam_file" .bam)
    sorted_bam="$dir/${basename}_sorted.bam"
    marked_bam="$dir/${basename}_sorted_marked.bam"
    run_command samtools sort "$bam_file" -o "$sorted_bam"
    run_command samtools markdup "$sorted_bam" "$marked_bam"
    run_command samtools index "$marked_bam"
    rm "$sorted_bam"
    rm "$bam_file"
done
echo "Step 3 completed."

# Step 4: Generating Gene Counts and Annotation
# In this final step, the pipeline focuses on quantifying gene expression. We use the featureCounts tool to count
# the number of reads mapped to each gene in the reference genome. This analysis is essential for understanding
# gene expression levels across different samples, which can be particularly useful for differential expression analysis.

# Step 4: Generating Gene Counts and Annotation
echo "Starting Step 4: Gene Counts and Annotation..."
annotation="/mnt/d/hg38/hg38.ensGene.gtf"
find "$FOLDER" -mindepth 1 -maxdepth 1 -type d | while read -r subfolder; do
    folder_name=$(basename "$subfolder")
    bam_files=$(find "$subfolder" -type f -name "*_sorted_marked.bam" -printf "%p ")
    if [ -n "$bam_files" ]; then
        output_counts="$subfolder/${folder_name}_expression_counts.txt"
        run_command featureCounts -a "$annotation" -o "$output_counts" -T 4 $bam_files
    fi
done
echo "Step 4 completed."

# Notify user process is complete
echo "All steps completed"
source ./logo.sh
